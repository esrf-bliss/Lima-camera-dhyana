//###########################################################################
// This file is part of LImA, a Library for Image Acquisition
//
// Copyright (C) : 2009-2014
// European Synchrotron Radiation Facility
// BP 220, Grenoble 38043
// FRANCE
//
// This is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3 of the License, or
// (at your option) any later version.
//
// This software is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, see <http://www.gnu.org/licenses/>.
//###########################################################################

#include <sstream>
#include <iostream>
#include <string>
#include <math.h>
#include <climits>
#include <iomanip>
#include <signal.h>
#include <unistd.h>
#include <errno.h>
#include "lima/Exceptions.h"
#include "lima/Debug.h"
#include "lima/MiscUtils.h"
#include "DhyanaTimer.h"

#include <time.h>
#include <sys/time.h>
#include <signal.h>
using namespace lima;
using namespace lima::Dhyana;
using namespace std;


//---------------------------
// @brief  ctor
//---------------------------    
CBaseTimer::CBaseTimer(int period) :
m_period_ms(period)
{

	DEB_CONSTRUCTOR();

	long m_period_sec = (m_period_ms / 1000); 
    long m_period_nsec = m_period_ms * 1e06;

	m_ts.it_value.tv_sec = m_period_sec;
    m_ts.it_value.tv_nsec = m_period_nsec;
    m_ts.it_interval.tv_sec = m_period_sec;
    m_ts.it_interval.tv_nsec = m_period_nsec;

	m_ts_reset.it_value.tv_sec = 0;
    m_ts_reset.it_value.tv_nsec = 0;
    m_ts_reset.it_interval.tv_sec = 0;
    m_ts_reset.it_interval.tv_nsec = 0;

	m_se.sigev_notify = SIGEV_THREAD;
    m_se.sigev_value.sival_ptr = this;
    m_se.sigev_notify_function = base_timer_proc;
    m_se.sigev_notify_attributes = NULL;

	if (-1 == timer_create(CLOCK_REALTIME, &m_se, &m_timer_id)) 
	{
		THROW_CTL_ERROR(Error) << "Error creating Timer.";
	}
}

//---------------------------
// @brief  dtor
//---------------------------   
CBaseTimer::~CBaseTimer()
{
	DEB_DESTRUCTOR();		
	stop();
}

//---------------------------
// @brief  start
//---------------------------   
void CBaseTimer::start()
{
	DEB_MEMBER_FUNCT();
	if (-1 == timer_settime(m_timer_id, 0, &m_ts, NULL))
	{
		THROW_CTL_ERROR(Error) << "Error arming Timer.";
	}
}

//---------------------------
// @brief  stop
//---------------------------   
void CBaseTimer::stop()
{
	DEB_MEMBER_FUNCT();
	if (-1 == timer_settime(m_timer_id, 0, &m_ts_reset, NULL)) 
	{
		THROW_CTL_ERROR(Error) << "Error disarming Timer.";
	}
}


/////////////////////////////
// USER MyTimer
/////////////////////////////

//---------------------------
// @brief  ctor
//---------------------------   
CSoftTriggerTimer::CSoftTriggerTimer(int period, Camera& cam) :
CBaseTimer(period),
m_cam(cam),
m_nb_frames(0),
m_nb_triggers(0)
{
	DEB_CONSTRUCTOR();		
}

//---------------------------
// @brief  dtor
//---------------------------   
CSoftTriggerTimer::~CSoftTriggerTimer()
{
	DEB_DESTRUCTOR();	
}

void CSoftTriggerTimer::start()
{
	DEB_MEMBER_FUNCT();
	m_nb_triggers = 0;
	CBaseTimer::start();
	m_cam.getNbFrames(m_nb_frames);		
}

void CSoftTriggerTimer::stop()
{
	DEB_MEMBER_FUNCT();
         CBaseTimer::stop();
         DEB_TRACE() << "Number of triggers generated by the Timer = "<<m_nb_triggers;
}

//---------------------------
// @brief  on_timer
//---------------------------   
void CSoftTriggerTimer::on_timer()
{
	DEB_MEMBER_FUNCT();
	//Generate software trigger for each frame, except for the first image
	//if((!m_cam.m_nb_frames || m_cam.m_acq_frame_nb < m_cam.m_nb_frames) && (m_cam.m_trigger_mode == IntTrig))
	{
		if(m_nb_triggers == m_cam.getNbHwAcquiredFrames() && m_nb_triggers < m_nb_frames)
		{
			m_nb_triggers++;
			//DEB_TRACE() << "CSoftTriggerTimer::on_timer : DoSoftwareTrigger - "<<m_nb_triggers;
			TUCAM_Cap_DoSoftwareTrigger(m_cam.m_opCam.hIdxTUCam);
		}
	}

	//This Timer is oneshot, stop() it 
	//stop();
}

//-----------------------------------------------------
//
//-----------------------------------------------------  
